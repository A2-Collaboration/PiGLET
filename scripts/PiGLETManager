#!/usr/bin/perl
use strict;
use warnings;

#use Data::TreeDumper;
use Getopt::Long;
use Pod::Usage;
use Switch;
use Net::Telnet;

# define the display sets $dispsets here
# as a hashref, the key is the "name" of the runset
# please provide a meaningful description of the displayset,

my $dispsets = {};

# define display sets CBTaggTAPS
$dispsets->{Test} =
  {
   'Description' => 'Messing around on localhost...',
   'Displays' => [
                  {
                   'Hostname' => 'localhost',
                   'Plots' => [
                               {'PV'=>'MyTestRecord0', 'BackLength'=>600},
                               {'PV'=>'MyTestRecord1', 'BackLength'=>100}
                              ]
                  }
                 ]
  };


# some default config options
# and provide nice help documentation
# some global variables, needed everywhere

my $man = 0;
my $help = 0;
my $verbose = 0;
my $warnings = 1;
my $exact = 0;
my $t; # telnet connection

Getopt::Long::Configure(qw(gnu_getopt));
GetOptions(
           'help|h' => \$help,
           'man' => \$man,
           'verbose|v+' => \$verbose,
           'warnings|w!' => \$warnings,
           'exact|e+' => \$exact
          ) or pod2usage(2);
pod2usage(1) if $help;
pod2usage(-exitval => 0, -verbose => 2) if $man;

if ($verbose) {
  # always enable warnings if verbose
  $warnings = 1;
}

# jump to subroutine which handles the job,
# depending on the options
my $mode = shift @ARGV || "";

switch($mode) {
  case "activate" { &Activate; }
  case "list" { &List; }
  else {
    Logger("Supplied mode not recognized, try --help or --man");
  }
}

sub Activate {
  my $dispset = $ARGV[0] || "";
  Logger("Specified dispset $dispset not found")
    unless defined $dispsets->{$dispset};

  Logger("Can't be that exact!")
    if $exact>3;
  Logger("Activating display set $dispset",1);
  # define a shortcut to the actual dispset data
  my $d = $dispsets->{$dispset};

  foreach my $disp (@{$d->{Displays}}) {
    WorkOnDisplay($disp);
  }

  Logger("Display set $dispset activated.",1);
}

sub List {
  print "The following display sets are available:\n";
  foreach my $dispset (sort keys $dispsets) {
    printf("* %-10s\t%s\n",$dispset,,$dispsets->{$dispset}->{Description});
  }
}



# helper functions

sub WorkOnDisplay {
  my $disp = shift;
  my $host = $disp->{Hostname};
  Logger("$host: Opening connection",2);

  $t = Net::Telnet->new(Timeout => 5, Port => 1337);
  $t->errmode("return");
  #$t->dump_log('STDERR');

  $t->open($host)
    or Logger("$host: Cannot open telnet connection: ".$t->errmsg);

  $t->waitfor(String => 'Welcome to PiGLET!')
    or Logger("$host: Did not receive welcome message: ".$t->errmsg);

  Logger("$host: Successfully connected.",2);

  # get the current windows via the List command.
  # search for words ending in _BackLength, which
  # indicate that it's a plot the pvname before it
  # TODO: Implement Image Windows...
  $t->print('List') or
    Logger("$host: Cannot send List command: ".$t->errmsg);
  $t->waitfor(String => 'Available commands:') or
    Logger("$host: Did not receive list of windows: ".$t->errmsg);
  my @words = split(/\s+/,$t->lastline);
  my %plots =
    map { s/(.+)_BackLength/$1/ ? ($_ => 1) : () } @words;

  my $n = scalar keys %plots;
  Logger("$host: Currently $n plots active.",2);

  if($exact==3) {
    ExecCmd("RemoveAllWindows");
  }

  # let's check if it complies with the display set
  foreach my $plot (@{$disp->{Plots}}) {
    my $pv = $plot->{PV}; # unique identier for plot windows
    if($exact==3 || !exists $plots{$pv}) {
      Logger("$host: Plot $pv not found. Adding it.", 2);
      ExecCmd("AddPlotWindow $pv");
      ExecCmd("${pv}_BackLength $plot->{BackLength}");
    }
    elsif($exact>=1) { # equals $exact==1 || $exact==2
      # ensure correct BackLength
      ExecCmd("${pv}_BackLength $plot->{BackLength}");
    }
    delete $plots{$pv};
  }

  # remove "unknown" windows
  if($exact == 2) {
    foreach my $pv (keys %plots) {
      Logger("$host: Removing unknown plot $pv", 2);
      ExecCmd("${pv}_Remove");
    }
  }

}

sub ExecCmd {
  my $host = $t->host;
  my $cmd = shift;
  $t->print($cmd) or
    Logger("$host: Cannot send Cmd '$cmd': ".$t->errmsg);
  $t->waitfor(String => 'Ok.') or
    Logger("$host: Did not receive 'Ok.' after '$cmd': ".$t->errmsg);
}

sub Logger {
  my $msg = shift;
  my $lvl = shift || 0; # 0=fatal, -1=warning, >0 verbose messages

  if ($lvl==0) {
    print STDERR "Error: $msg\n";
    exit 1;
  }
  elsif($lvl==-1) {
    print STDERR "Warning: $msg\n" if $warnings;
  }
  else {
    print "$msg\n" if $lvl<=$verbose;
  }
}

__END__

=head1 NAME

PiGLETManager - Interface to PiGLET (Raspberry Pi OpenGL EPICS Toolkit)

=head1 SYNOPSIS

PiGLETManager activate <displayset>

PiGLETManager list

 Options:
   -h, --help     brief help message
   -v, --verbose  be verbose to STDERR
   -w, --warnings print warnings to STDERR
   -e, --exact    set display more precisely

=head1 OPTIONS

=over 8

=item B<--help>

Print a brief help message and exits.

=item B<--verbose>

Print some information what is going on. Default off.

=item B<--warnings>

Print warnings (or "not-so-fatal" errors). Default on.

=item B<--exact>

If specified once, the BackLength's are reset even if the window
exists.

If specified twice (e.g. -ee), then additionally unknown windows are
removed.

If specified three times (e.g. -eee), everything is removed and added
from scratch. Note: This also deletes the history of the graphs and
reloads the metadata like yrange from EPICS.

=back

=head1 DESCRIPTION

=cut
